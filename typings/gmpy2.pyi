"""
Type stubs for gmpy2 - GNU Multiple Precision Arithmetic Library interface
This file provides type hints for the gmpy2 library functions used in Feldman VSS.
"""

from typing import Any, Callable, Optional, Tuple, TypeVar, Union

# Type definitions
T = TypeVar('T')
_mpz_type = Any  # Used to represent the concrete mpz type

class mpz:
    """Multiple precision integer type"""
    
    def __new__(cls, x: Union[int, str, float, 'mpz', 'mpfr', 'mpq', 'mpc', bytes] = 0, base: int = 0) -> 'mpz': ...
    def __init__(self, x: Union[int, str, float, 'mpz', 'mpfr', 'mpq', 'mpc', bytes] = 0, base: int = 0) -> None: ...
    
    def __str__(self) -> str: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __repr__(self) -> str: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __format__(self, format_spec: str) -> str: ...
    
    def __lt__(self, other: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> bool: ...
    def __le__(self, other: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __gt__(self, other: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> bool: ...
    def __ge__(self, other: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> bool: ...
    
    def __add__(self, other: Union[int, 'mpz', 'mpfr']) -> Union['mpz', 'mpfr']: ...
    def __radd__(self, other: Union[int, 'mpz', 'mpfr']) -> Union['mpz', 'mpfr']: ...
    def __sub__(self, other: Union[int, 'mpz', 'mpfr']) -> Union['mpz', 'mpfr']: ...
    def __rsub__(self, other: Union[int, 'mpz', 'mpfr']) -> Union['mpz', 'mpfr']: ...
    def __mul__(self, other: Union[int, 'mpz', 'mpfr']) -> Union['mpz', 'mpfr']: ...
    def __rmul__(self, other: Union[int, 'mpz', 'mpfr']) -> Union['mpz', 'mpfr']: ...
    def __floordiv__(self, other: Union[int, 'mpz']) -> 'mpz': ...
    def __rfloordiv__(self, other: Union[int, 'mpz']) -> 'mpz': ...
    def __truediv__(self, other: Union[int, 'mpz', 'mpfr']) -> 'mpfr': ...
    def __rtruediv__(self, other: Union[int, 'mpz', 'mpfr']) -> 'mpfr': ...
    def __divmod__(self, other: Union[int, 'mpz']) -> Tuple['mpz', 'mpz']: ...
    def __rdivmod__(self, other: Union[int, 'mpz']) -> Tuple['mpz', 'mpz']: ...
    def __mod__(self, other: Union[int, 'mpz']) -> 'mpz': ...
    def __rmod__(self, other: Union[int, 'mpz']) -> 'mpz': ...
    def __pow__(self, other: Union[int, 'mpz'], mod: Optional[Union[int, 'mpz']] = None) -> 'mpz': ...
    def __rpow__(self, other: Union[int, 'mpz'], mod: Optional[Union[int, 'mpz']] = None) -> 'mpz': ...
    def __lshift__(self, other: Union[int, 'mpz']) -> 'mpz': ...
    def __rlshift__(self, other: Union[int, 'mpz']) -> 'mpz': ...
    def __rshift__(self, other: Union[int, 'mpz']) -> 'mpz': ...
    def __rrshift__(self, other: Union[int, 'mpz']) -> 'mpz': ...
    def __and__(self, other: Union[int, 'mpz']) -> 'mpz': ...
    def __rand__(self, other: Union[int, 'mpz']) -> 'mpz': ...
    def __or__(self, other: Union[int, 'mpz']) -> 'mpz': ...
    def __ror__(self, other: Union[int, 'mpz']) -> 'mpz': ...
    def __xor__(self, other: Union[int, 'mpz']) -> 'mpz': ...
    def __rxor__(self, other: Union[int, 'mpz']) -> 'mpz': ...
    def __neg__(self) -> 'mpz': ...
    def __pos__(self) -> 'mpz': ...
    def __abs__(self) -> 'mpz': ...
    def __invert__(self) -> 'mpz': ...
    
    def bit_length(self) -> int: ...
    def bit_test(self, n: int) -> bool: ...
    def bit_set(self, n: int) -> 'mpz': ...
    def bit_clear(self, n: int) -> 'mpz': ...
    def bit_flip(self, n: int) -> 'mpz': ...
    def bit_scan0(self, starting_bit: int = 0) -> int: ...
    def bit_scan1(self, starting_bit: int = 0) -> int: ...
    def num_digits(self, base: int = 10) -> int: ...
    def is_square(self) -> bool: ...
    def is_power(self) -> bool: ...
    def is_prime(self, n: int = 25) -> bool: ...
    def is_probab_prime(self, n: int = 25) -> int: ...
    def is_congruent(self, other: Union[int, 'mpz'], mod: Union[int, 'mpz']) -> bool: ...
    def to_bytes(self, length: int, byteorder: str, *, signed: bool = False) -> bytes: ...
    
    @classmethod
    def from_bytes(cls, bytes_val: bytes, byteorder: str, *, signed: bool = False) -> 'mpz': ...

class mpq:
    """Multiple precision rational type"""
    
    def __new__(cls, num: Union[int, str, float, 'mpz', 'mpfr', 'mpq', bytes] = 0, 
                den: Union[int, 'mpz'] = 1, base: int = 10) -> 'mpq': ...
    def __init__(self, num: Union[int, str, float, 'mpz', 'mpfr', 'mpq', bytes] = 0, 
                den: Union[int, 'mpz'] = 1, base: int = 10) -> None: ...
    
    def __str__(self) -> str: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __repr__(self) -> str: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    
    def __lt__(self, other: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> bool: ...
    def __le__(self, other: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __gt__(self, other: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> bool: ...
    def __ge__(self, other: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> bool: ...
    
    def __add__(self, other: Union[int, 'mpz', 'mpfr', 'mpq']) -> Union['mpq', 'mpfr']: ...
    def __radd__(self, other: Union[int, 'mpz', 'mpfr', 'mpq']) -> Union['mpq', 'mpfr']: ...
    def __sub__(self, other: Union[int, 'mpz', 'mpfr', 'mpq']) -> Union['mpq', 'mpfr']: ...
    def __rsub__(self, other: Union[int, 'mpz', 'mpfr', 'mpq']) -> Union['mpq', 'mpfr']: ...
    def __mul__(self, other: Union[int, 'mpz', 'mpfr', 'mpq']) -> Union['mpq', 'mpfr']: ...
    def __rmul__(self, other: Union[int, 'mpz', 'mpfr', 'mpq']) -> Union['mpq', 'mpfr']: ...
    def __truediv__(self, other: Union[int, 'mpz', 'mpfr', 'mpq']) -> Union['mpq', 'mpfr']: ...
    def __rtruediv__(self, other: Union[int, 'mpz', 'mpfr', 'mpq']) -> Union['mpq', 'mpfr']: ...
    def __neg__(self) -> 'mpq': ...
    def __pos__(self) -> 'mpq': ...
    def __abs__(self) -> 'mpq': ...
    
    def numerator(self) -> 'mpz': ...
    def denominator(self) -> 'mpz': ...
    
class mpfr:
    """Multiple precision floating-point type"""
    
    def __new__(cls, x: Union[int, str, float, 'mpz', 'mpfr', 'mpq', 'mpc', bytes] = 0, 
                base: int = 0, precision: int = 0) -> 'mpfr': ...
    def __init__(self, x: Union[int, str, float, 'mpz', 'mpfr', 'mpq', 'mpc', bytes] = 0, 
                base: int = 0, precision: int = 0) -> None: ...
    
    def __str__(self) -> str: ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def __repr__(self) -> str: ...
    def __bool__(self) -> bool: ...
    def __hash__(self) -> int: ...
    def __format__(self, format_spec: str) -> str: ...
    
    def __lt__(self, other: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> bool: ...
    def __le__(self, other: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> bool: ...
    def __eq__(self, other: object) -> bool: ...
    def __ne__(self, other: object) -> bool: ...
    def __gt__(self, other: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> bool: ...
    def __ge__(self, other: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> bool: ...
    
    def __add__(self, other: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> 'mpfr': ...
    def __radd__(self, other: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> 'mpfr': ...
    def __sub__(self, other: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> 'mpfr': ...
    def __rsub__(self, other: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> 'mpfr': ...
    def __mul__(self, other: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> 'mpfr': ...
    def __rmul__(self, other: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> 'mpfr': ...
    def __truediv__(self, other: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> 'mpfr': ...
    def __rtruediv__(self, other: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> 'mpfr': ...
    def __pow__(self, other: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> 'mpfr': ...
    def __rpow__(self, other: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> 'mpfr': ...
    def __neg__(self) -> 'mpfr': ...
    def __pos__(self) -> 'mpfr': ...
    def __abs__(self) -> 'mpfr': ...
    
    def is_integer(self) -> bool: ...
    def is_zero(self) -> bool: ...
    def is_nan(self) -> bool: ...
    def is_inf(self) -> bool: ...
    def is_finite(self) -> bool: ...
    def is_signed(self) -> bool: ...
    def precision(self) -> int: ...

class mpc:
    """Multi-precision complex number type"""
    
    def __new__(cls, re: Union[int, str, float, 'mpz', 'mpfr', 'mpc', bytes] = 0, 
                im: Union[int, str, float, 'mpz', 'mpfr', 'mpc', bytes] = 0, 
                base: int = 0, 
                precision: int = 0) -> 'mpc': ...
    
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
    def __bool__(self) -> bool: ...
    
    def __add__(self, other: Union[int, 'mpc', 'mpfr', 'mpz']) -> 'mpc': ...
    def __radd__(self, other: Union[int, 'mpc', 'mpfr', 'mpz']) -> 'mpc': ...
    def __sub__(self, other: Union[int, 'mpc', 'mpfr', 'mpz']) -> 'mpc': ...
    def __rsub__(self, other: Union[int, 'mpc', 'mpfr', 'mpz']) -> 'mpc': ...
    def __mul__(self, other: Union[int, 'mpc', 'mpfr', 'mpz']) -> 'mpc': ...
    def __rmul__(self, other: Union[int, 'mpc', 'mpfr', 'mpz']) -> 'mpc': ...
    def __truediv__(self, other: Union[int, 'mpc', 'mpfr', 'mpz']) -> 'mpc': ...
    def __rtruediv__(self, other: Union[int, 'mpc', 'mpfr', 'mpz']) -> 'mpc': ...
    def __pow__(self, other: Union[int, 'mpc', 'mpfr', 'mpz']) -> 'mpc': ...
    def __rpow__(self, other: Union[int, 'mpc', 'mpfr', 'mpz']) -> 'mpc': ...
    def __neg__(self) -> 'mpc': ...
    def __abs__(self) -> 'mpfr': ...
    
    def conjugate(self) -> 'mpc': ...
    def real(self) -> 'mpfr': ...
    def imag(self) -> 'mpfr': ...
    def phase(self) -> 'mpfr': ...
    def norm(self) -> 'mpfr': ...

# General functions
def version() -> str: ...
def mp_version() -> str: ...
def get_cache() -> Tuple[int, int]: ...
def set_cache(size: int, limbs: int = 1) -> Tuple[int, int]: ...
def get_max_precision() -> int: ...
def set_max_precision(precision: int) -> int: ...
def get_minprec() -> int: ...
def get_maxprec() -> int: ...

# Number theoretic functions
def powmod(x: Union[int, 'mpz'], y: Union[int, 'mpz'], m: Union[int, 'mpz']) -> 'mpz': ...
def invert(x: Union[int, 'mpz'], m: Union[int, 'mpz']) -> 'mpz': ...
def is_prime(x: Union[int, 'mpz'], n: int = 25) -> bool: ...
def is_probab_prime(x: Union[int, 'mpz'], n: int = 25) -> int: ...
def gcd(x: Union[int, 'mpz'], y: Union[int, 'mpz']) -> 'mpz': ...
def lcm(x: Union[int, 'mpz'], y: Union[int, 'mpz']) -> 'mpz': ...
def gcdext(a: Union[int, 'mpz'], b: Union[int, 'mpz']) -> Tuple['mpz', 'mpz', 'mpz']: ...
def divm(a: Union[int, 'mpz'], b: Union[int, 'mpz'], m: Union[int, 'mpz']) -> 'mpz': ...
def fac(n: Union[int, 'mpz']) -> 'mpz': ...
def fib(n: Union[int, 'mpz']) -> 'mpz': ...
def fib2(n: Union[int, 'mpz']) -> Tuple['mpz', 'mpz']: ...
def lucas(n: Union[int, 'mpz']) -> 'mpz': ...
def lucas2(n: Union[int, 'mpz']) -> Tuple['mpz', 'mpz']: ...
def jacobi(a: Union[int, 'mpz'], b: Union[int, 'mpz']) -> int: ...
def legendre(a: Union[int, 'mpz'], p: Union[int, 'mpz']) -> int: ...
def kronecker(a: Union[int, 'mpz'], b: Union[int, 'mpz']) -> int: ...
def next_prime(x: Union[int, 'mpz']) -> 'mpz': ...
def prev_prime(x: Union[int, 'mpz']) -> 'mpz': ...

# Core arithmetic functions
def add(x: Union[int, 'mpz', 'mpfr', 'mpq'], y: Union[int, 'mpz', 'mpfr', 'mpq']) -> Union['mpz', 'mpfr', 'mpq']: ...
def sub(x: Union[int, 'mpz', 'mpfr', 'mpq'], y: Union[int, 'mpz', 'mpfr', 'mpq']) -> Union['mpz', 'mpfr', 'mpq']: ...
def mul(x: Union[int, 'mpz', 'mpfr', 'mpq'], y: Union[int, 'mpz', 'mpfr', 'mpq']) -> Union['mpz', 'mpfr', 'mpq']: ...
def div(x: Union[int, 'mpz', 'mpfr', 'mpq'], y: Union[int, 'mpz', 'mpfr', 'mpq']) -> Union['mpfr', 'mpq']: ...
def divmod(x: Union[int, 'mpz'], y: Union[int, 'mpz']) -> Tuple['mpz', 'mpz']: ...
def mod(x: Union[int, 'mpz'], y: Union[int, 'mpz']) -> 'mpz': ...
def sqrt(x: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> Union['mpz', 'mpfr']: ...
def isqrt(x: Union[int, 'mpz']) -> 'mpz': ...
def isqrt_rem(x: Union[int, 'mpz']) -> Tuple['mpz', 'mpz']: ...
def square(x: Union[int, 'mpz', 'mpfr', 'mpq']) -> Union['mpz', 'mpfr', 'mpq']: ...

# Random number generators
def random_state(seed: Optional[Union[int, str, bytes, Any]] = None) -> Any: ...
def mpz_random(state: Any, n: Union[int, 'mpz']) -> 'mpz': ...
def mpz_rrandomb(state: Any, b: int) -> 'mpz': ...
def mpz_urandomb(state: Any, b: int) -> 'mpz': ...

# Other utility functions
def bincoef(n: Union[int, 'mpz'], k: Union[int, 'mpz']) -> 'mpz': ...
def hamdist(x: Union[int, 'mpz'], y: Union[int, 'mpz']) -> int: ...
def popcount(x: Union[int, 'mpz']) -> int: ...
def xmpz_popcount(x: Union[int, 'mpz']) -> int: ...
def bit_mask(n: int) -> 'mpz': ...

# MPFR specific functions
def const_log2() -> 'mpfr': ...
def const_pi() -> 'mpfr': ...
def const_euler() -> 'mpfr': ...
def const_catalan() -> 'mpfr': ...
def log(x: Union[int, float, 'mpz', 'mpfr', 'mpq'], base: Optional[Union[int, float, 'mpz', 'mpfr']] = None) -> 'mpfr': ...
def exp(x: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> 'mpfr': ...
def sin(x: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> 'mpfr': ...
def cos(x: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> 'mpfr': ...
def tan(x: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> 'mpfr': ...
def atan(x: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> 'mpfr': ...
def sinh(x: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> 'mpfr': ...
def cosh(x: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> 'mpfr': ...
def tanh(x: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> 'mpfr': ...
def atanh(x: Union[int, float, 'mpz', 'mpfr', 'mpq']) -> 'mpfr': ...

# Internal support for mpmath
_mpmath_create: Callable[..., Any]
_mpmath_normalize: Callable[..., Any]

# Internal C API
_C_API: Any

# Constants
__version__: str
__libgmp_version__: str
__libmpfr_version__: str
__libmpc_version__: str

# For IDE autocompletion
__all__ = [
    'mpz', 'mpq', 'mpfr', 'mpc', 'add', 'sub', 'mul', 'div', 'divmod', 'mod',
    'powmod', 'invert', 'is_prime', 'gcd', 'lcm', 'sqrt', 'isqrt', 'square',
    'random_state', 'version', 'mp_version', 'get_cache', 'set_cache',
    'is_probab_prime', 'next_prime', 'prev_prime', 'jacobi', 'legendre',
    'kronecker', 'gcdext', 'divm', 'fac', 'bincoef', 'fib', 'fib2', 'lucas', 'lucas2',
    'hamdist', 'popcount', 'bit_mask', 'const_log2', 'const_pi', 'const_euler',
    'const_catalan', 'log', 'exp', 'sin', 'cos', 'tan', 'atan', 'sinh', 'cosh', 
    'tanh', 'atanh', 'mpz_random', 'mpz_rrandomb', 'mpz_urandomb',
    '__version__', '__libgmp_version__', '__libmpfr_version__', '__libmpc_version__',
    '_mpmath_create', '_mpmath_normalize', '_C_API'
]